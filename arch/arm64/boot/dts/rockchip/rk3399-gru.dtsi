/*
 * Google Gru (and derivatives) board device tree source
 *
 * Copyright 2016 Google, Inc
 *
 * This file is dual-licensed: you can use it either under the terms
 * of the GPL or the X11 license, at your option. Note that this dual
 * licensing only applies to this file, and not this project as a
 * whole.
 *
 *  a) This file is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU General Public License as
 *     published by the Free Software Foundation; either version 2 of the
 *     License, or (at your option) any later version.
 *
 *     This file is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *  Or, alternatively,
 *
 *  b) Permission is hereby granted, free of charge, to any person
 *     obtaining a copy of this software and associated documentation
 *     files (the "Software"), to deal in the Software without
 *     restriction, including without limitation the rights to use,
 *     copy, modify, merge, publish, distribute, sublicense, and/or
 *     sell copies of the Software, and to permit persons to whom the
 *     Software is furnished to do so, subject to the following
 *     conditions:
 *
 *     The above copyright notice and this permission notice shall be
 *     included in all copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *     OTHER DEALINGS IN THE SOFTWARE.
 */

#include <dt-bindings/input/input.h>
#include <dt-bindings/pwm/pwm.h>
#include "rk3399.dtsi"

/ {
	/*
	 * Power Tree
	 *
	 * In general an attempt is made to include all rails called out by
	 * the schematic as long as those rails interact in some way with
	 * the AP.  AKA:
	 * - Rails that only connect to the EC (or devices that the EC talks to)
	 *   are not included.
	 * - Rails _are_ included if the rails go to the AP even if the AP
	 *   doesn't currently care about them / they are always on.  The idea
	 *   here is that it makes it easier to map to the schematic or extend
	 *   later.
	 *
	 * If two rails are substantially the same from the AP's point of
	 * view, though, we won't create a full fixed regulator.  We'll just
	 * put the child rail as an alias of the parent rail.  Sometimes rails
	 * look the same to the AP because one of these is true:
	 * - The EC controls the enable and the EC always enables a rail as
	 *   long as the AP is running.
	 * - The rails are actually connected to each other by a jumper and
	 *   the distinction is just there to add clarity/flexibility to the
	 *   schematic.
	 */

	/* parentless regulators */

	ppvar_sys: ppvar-sys {
		compatible = "regulator-fixed";
		regulator-name = "ppvar_sys";
		regulator-always-on;
		regulator-boot-on;
	};

	/* ppvar_sys children, sorted by name */

	pp900_ap: pp900-ap {
		compatible = "regulator-fixed";
		regulator-name = "pp900_ap";

		/* EC turns on w/ pp900_ap_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <900000>;
		regulator-max-microvolt = <900000>;

		vin-supply = <&ppvar_sys>;
	};

	pp1200_lpddr: pp1200-lpddr {
		compatible = "regulator-fixed";
		regulator-name = "pp1200_lpddr";

		/* EC turns on w/ lpddr_pwr_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <1200000>;
		regulator-max-microvolt = <1200000>;

		vin-supply = <&ppvar_sys>;
	};

	pp1800: pp1800 {
		compatible = "regulator-fixed";
		regulator-name = "pp1800";

		/* Always on when ppvar_sys shows power good */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		vin-supply = <&ppvar_sys>;
	};

	pp3000: pp3000 {
		compatible = "regulator-fixed";
		regulator-name = "pp3000";
		pinctrl-names = "default";
		pinctrl-0 = <&pp3000_en>;

		enable-active-high;
		gpio = <&gpio0 12 GPIO_ACTIVE_HIGH>;

		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <3000000>;
		regulator-max-microvolt = <3000000>;

		vin-supply = <&ppvar_sys>;
	};

	pp3300: pp3300 {
		compatible = "regulator-fixed";
		regulator-name = "pp3300";

		/* Always on; plain and simple */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;

		vin-supply = <&ppvar_sys>;
	};

	pp5000: pp5000 {
		compatible = "regulator-fixed";
		regulator-name = "pp5000";

		/* EC turns on w/ pp5000_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;

		vin-supply = <&ppvar_sys>;
	};

	ppvar_bigcpu: ppvar-bigcpu {
		compatible = "pwm-regulator";
		regulator-name = "ppvar_bigcpu";
		status = "okay";

		pwms = <&pwm1 0 3333 0>;

		// TODO: where's the mapping of duty cycle to voltage???
		// TODO: we probably need in-flight PWM regulator series?

		/* EC turns on w/ ap_core_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <800000>;
		regulator-max-microvolt = <1500000>;

		pwm-supply = <&ppvar_sys>;
	};

	ppvar_litcpu: ppvar-litcpu {
		compatible = "pwm-regulator";
		regulator-name = "ppvar_litcpu";
		status = "okay";

		pwms = <&pwm2 0 3333 0>;

		/* EC turns on w/ ap_core_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <800000>;
		regulator-max-microvolt = <1500000>;

		pwm-supply = <&ppvar_sys>;
	};

	ppvar_gpu: ppvar-gpu {
		compatible = "pwm-regulator";
		regulator-name = "ppvar_gpu";
		status = "okay";

		pwms = <&pwm0 0 3333 0>;

		/* EC turns on w/ ap_core_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <800000>;
		regulator-max-microvolt = <1500000>;

		pwm-supply = <&ppvar_sys>;
	};

	ppvar_centerlogic: ppvar-centerlogic {
		compatible = "pwm-regulator";
		regulator-name = "ppvar_centerlogic";
		status = "okay";

		pwms = <&pwm3 0 3333 0>;

		/* EC turns on w/ ppvar_centerlogic_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <800000>;
		regulator-max-microvolt = <1500000>;

		pwm-supply = <&ppvar_sys>;
	};

	/* Schematics call this PPVAR even though it's fixed */
	ppvar_logic: ppvar-logic {
		compatible = "regulator-fixed";
		regulator-name = "ppvar_logic";

		/* EC turns on w/ ppvar_logic_en; always on for AP */
		regulator-always-on;
		regulator-boot-on;

		regulator-min-microvolt = <900000>;
		regulator-max-microvolt = <900000>;

		vin-supply = <&ppvar_sys>;
	};

	/* pp900_ap aliases; these are always on for AP so just use alias */

	/* EC turns on w/ pp900_ddrpll_en */
	pp900_ddrpll: pp900_ap {
	};

	/* EC turns on w/ pp900_pcie_en */
	pp900_pcie: pp900_ap {
	};

	/* EC turns on w/ pp900_pll_en */
	pp900_pll: pp900_ap {
	};

	/* EC turns on w/ pp900_pmu_en */
	pp900_pmu: pp900_ap {
	};

	/* EC turns on w/ pp900_usb_en */
	pp900_usb: pp900_ap {
	};

	/* pp1800 aliases; these are always on for AP so just use alias */

	/* EC turns on w/ pp1800_s0_en_l */
	pp1800_ap_io: pp1800_emmc: pp1800_nfc: pp1800_s0: pp1800 {
	};

	/* EC turns on w/ pp1800_avdd_en_l */
	pp1800_avdd: pp1800 {
	};

	/* EC turns on w/ pp1800_lid_en_l */
	pp1800_lid: pp1800_mic: pp1800 {
	};

	/* EC turns on w/ lpddr_pwr_en */
	pp1800_lpddr: pp1800 {
	};

	/* EC turns on w/ pp1800_pmu_en_l */
	pp1800_pmu: pp1800 {
	};

	/* EC turns on w/ pp1800_usb_en_l */
	pp1800_usb: pp1800 {
	};

	/* pp1800 children */

	pp1500_ap_io: pp1500-ap-io {
		compatible = "regulator-fixed";
		regulator-name = "pp1500_ap_io";
		pinctrl-names = "default";
		pinctrl-0 = <&pp1500_en>;

		enable-active-high;
		gpio = <&gpio1 11 GPIO_ACTIVE_HIGH>;

		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <1500000>;
		regulator-max-microvolt = <1500000>;

		vin-supply = <&pp1800>;
	};

	pp1800_audio: pp1800-audio {
		compatible = "regulator-fixed";
		regulator-name = "pp1800_audio";
		pinctrl-names = "default";
		pinctrl-0 = <&pp1800_audio_en>;

		regulator-always-on;
		regulator-boot-on;

		enable-active-high;
		gpio = <&gpio0 2 GPIO_ACTIVE_HIGH>;

		vin-supply = <&pp1800>;
	};

	pp1800_pcie: pp1800-pcie {
		compatible = "regulator-fixed";
		regulator-name = "pp1800_pcie";
		pinctrl-names = "default";
		pinctrl-0 = <&wlan_module_pd_l>;

		enable-active-high;
		gpio = <&gpio0 4 GPIO_ACTIVE_HIGH>;

		vin-supply = <&pp1800>;
	};

	/* pp3000 aliases; these are always on for AP so just use alias */

	/* Always on; plain and simple */
	pp3000_ap: pp3000_emmc: pp3000 {
	};

	/* pp3000 children */

	pp3000_sd_slot: pp3000-sd-slot {
		compatible = "regulator-fixed";
		regulator-name = "pp3000_sd_slot";
		pinctrl-names = "default";
		pinctrl-0 = <&sd_slot_pwr_en>;

		enable-active-high;
		gpio = <&gpio4 29 GPIO_ACTIVE_HIGH>;

		vin-supply = <&pp3000>;
	};

	ppvar_sd_card_io: ppvar-sd-card-io {
		compatible = "regulator-gpio";
		regulator-name = "ppvar_sd_card_io";
		pinctrl-names = "default";
		pinctrl-0 = <&sd_io_pwr_en &sd_pwr_1800_sel>;

		enable-active-high;
		enable-gpio = <&gpio2 2 GPIO_ACTIVE_HIGH>;
		gpios = <&gpio2 28 GPIO_ACTIVE_HIGH>;
		states = <1800000 0x1
			  3000000 0x0>;

		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <3000000>;

		// TODO: add support in driver for input supplies.
		// ...and specify pp3000 and pp1800.
	};

	/* pp3300 aliases; these are always on for AP so just use alias */

	/* EC turns on w/ pp3300_trackpad_en_l */
	pp3300_trackpad: pp3300-trackpad {
	};

	/* EC turns on w/ pp3300_usb_en_l */
	pp3300_usb: pp3300 {
	};

	/* pp3300 children */

	// TODO: this regulator should get referenced by the
	// EC<-->AP backlight driver. See http://crosbug.com/p/52005
	pp3300_disp: pp3300-disp {
		compatible = "regulator-fixed";
		regulator-name = "pp3300_disp";
		pinctrl-names = "default";
		pinctrl-0 = <&pp3300_disp_en>;

		enable-active-high;

		gpio = <&gpio4 27 GPIO_ACTIVE_HIGH>;

		vin-supply = <&pp3300>;
	};

	pp3300_wifi_bt:pp3300-wifi-bt {
		compatible = "regulator-fixed";
		regulator-name = "pp3300_wifi_bt";
		/* NOTE: wlan_module_pd_l pinctrl in pp1800_pcie */

		regulator-always-on;			// TODO: for bringup???
		regulator-boot-on;			// TODO: for bringup???
		enable-active-high;

		// TODO: I _think_ it's OK to specify the same GPIO in two
		// regulator-fixed regulators.  See pp1800_pcie
		gpio = <&gpio0 8 GPIO_ACTIVE_HIGH>;

		vin-supply = <&pp3300>;
	};


	/* END REGULATORS */

	io-domains {
		compatible = "rockchip,rk3399-io-voltage-domain";
		rockchip,grf = <&grf>;

		bt656-supply = <&pp1800_ap_io>;		/* APIO2_VDD;  2a 2b */
		audio-supply = <&pp1800_audio>;		/* APIO5_VDD;  3d 4a */
		sdmmc-supply = <&ppvar_sd_card_io>;	/* SDMMC0_VDD; 4b    */
		gpio1830-supply = <&pp3000_ap>;		/* APIO4_VDD;  4c 4d */
	};

	pmu-io-domains {
		compatible = "rockchip,rk3399-pmu-io-voltage-domain";
		rockchip,grf = <&pmugrf>;

		pmu1830-supply = <&pp1800_pmu>;		/* PMUIO2_VDD */
	};
};

&cpu_l0 {
	cpu-supply = <&ppvar_litcpu>;
};

&cpu_l1 {
	cpu-supply = <&ppvar_litcpu>;
};

&cpu_l2 {
	cpu-supply = <&ppvar_litcpu>;
};

&cpu_l3 {
	cpu-supply = <&ppvar_litcpu>;
};

&cpu_b0 {
	cpu-supply = <&ppvar_bigcpu>;
};

&cpu_b1 {
	cpu-supply = <&ppvar_bigcpu>;
};

&emmc_phy {
	status = "okay";
};

&i2s0 {
	status = "okay";
};

/* HACK THE PWM REGULATORS OUT
 *
 * Poorly formatted on purpose so you it's a hack.
 *
 * We'll hack them all to pretend they are fixed regulators
 * and at exactly .9V, which is where cpufreq wants them.
 *
 * We'll also set all PWMs to disabled so we know that the PWM
 * framework won't touch them.
 *
 * This relies on PWM clock being a critical clock.
 */
&ppvar_bigcpu {
compatible = "regulator-fixed";
regulator-min-microvolt = <900000>;
regulator-max-microvolt = <900000>;
};
&ppvar_centerlogic {
compatible = "regulator-fixed";
regulator-min-microvolt = <900000>;
regulator-max-microvolt = <900000>;
};
&ppvar_litcpu {
compatible = "regulator-fixed";
regulator-min-microvolt = <900000>;
regulator-max-microvolt = <900000>;
};
&ppvar_gpu {
compatible = "regulator-fixed";
regulator-min-microvolt = <900000>;
regulator-max-microvolt = <900000>;
};
// &pwm0 {
// 	status = "okay";
// };
//
// &pwm1 {
// 	status = "okay";
// };
//
// &pwm2 {
// 	status = "okay";
// };
//
// &pwm3 {
// 	status = "okay";
// };

&sdhci {
	bus-width = <8>;
	mmc-hs400-1_8v;
	non-removable;
	status = "okay";
};

&sdmmc {
	status = "okay";

	/*
	 * Note: configure "sdmmc_cd" as card detect even though it's actually
	 * hooked to ground.  Because we specified "cd-gpios" below dw_mmc
	 * should be ignoring card detect anyway.  Specifying the pin as
	 * sdmmc_cd means that even if you've got GRF_SOC_CON7[12] (force_jtag)
	 * turned on that the system will still make sure the port is
	 * configured as SDMMC and not JTAG.
	 */
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_cd &sdmmc_cd_gpio
		     &sdmmc_bus4>;

	bus-width = <4>;
	cd-gpios = <&gpio4 24 GPIO_ACTIVE_LOW>;
	disable-wp;

	cap-mmc-highspeed;
	cap-sd-highspeed;
	sd-uhs-sdr12;
	sd-uhs-sdr25;
	sd-uhs-sdr50;
	sd-uhs-sdr104;

	vmmc-supply = <&pp3000_sd_slot>;
	vqmmc-supply = <&ppvar_sd_card_io>;
};

&spi1 {
	status = "okay";

	spiflash@0 {
		compatible = "jedec,spi-nor";

		// TODO: can run faster once verified.
		// TODO: add rx-sample-delay-ns.
		spi-max-frequency = <10000000>;
		reg = <0>;
	};
};

&spi5 {
	status = "okay";

	cros_ec: ec@0 {
		compatible = "google,cros-ec-spi";
		reg = <0>;
		pinctrl-names = "default";
		pinctrl-0 = <&ec_ap_int_l>;

		google,cros-ec-spi-pre-delay = <30>;	// TODO: check
		interrupt-parent = <&gpio0>;
		interrupts = <1 IRQ_TYPE_LEVEL_LOW>;
		spi-max-frequency = <3000000>;		// TODO: check; TODO: rx-sample-delay-ns?

		i2c_tunnel: i2c-tunnel {
			compatible = "google,cros-ec-i2c-tunnel";
			google,remote-bus = <4>;
			#address-cells = <1>;
			#size-cells = <0>;
		};
	};
};

&uart2 {
	status = "okay";
};

&usb_host0_ehci {
	status = "okay";
};

&usb_host0_ohci {
	status = "okay";
};

&usb_host1_ehci {
	status = "okay";
};

&usb_host1_ohci {
	status = "okay";
};

&usbdrd3_0 {
	status = "okay";
};

&usbdrd_dwc3_0 {
	status = "okay";
	dr_mode = "host";
};

&usbdrd3_1 {
	status = "okay";
};

&usbdrd_dwc3_1 {
	status = "okay";
	dr_mode = "host";
};

#include "common/cros-ec-keyboard.dtsi"
#include "common/cros-ec-sbs.dtsi"

/* PINCTRL: always below everything else */

&pinctrl {
	pcfg_output_high: pcfg-output-high {
		output-high;
	};

	pcfg_pull_none_8ma: pcfg-pull-none-8ma {
		bias-disable;
		drive-strength = <8>;
	};

	cros-ec {
		ec_ap_int_l: ec-ap-int-l {
			rockchip,pins = <RK_GPIO0 1 RK_FUNC_GPIO &pcfg_pull_up>;
		};
	};

	discrete-regulators {
		pp1500_en: pp1500-en {
			rockchip,pins = <RK_GPIO0 10 RK_FUNC_GPIO
					 &pcfg_pull_none>;
		};

		pp1800_audio_en: pp1800-audio-en {
			rockchip,pins = <RK_GPIO0 2 RK_FUNC_GPIO
					 &pcfg_pull_down>;
		};

		pp3300_disp_en: pp3300-disp-en {
			rockchip,pins = <RK_GPIO4 27 RK_FUNC_GPIO
					 &pcfg_pull_none>;
		};

		pp3000_en: pp3000-en {
			rockchip,pins = <RK_GPIO0 12 RK_FUNC_GPIO
					 &pcfg_pull_none>;
		};

		sd_io_pwr_en: sd-io-pwr-en {
			rockchip,pins = <RK_GPIO2 2 RK_FUNC_GPIO
					 &pcfg_pull_none>;
		};

		sd_pwr_1800_sel: sd-pwr-1800-sel {
			rockchip,pins = <RK_GPIO2 28 RK_FUNC_GPIO
					 &pcfg_pull_none>;
		};

		sd_slot_pwr_en: sd-slot-pwr-en {
			rockchip,pins = <RK_GPIO4 29 RK_FUNC_GPIO
					 &pcfg_pull_none>;
		};

		wlan_module_pd_l: wlan-module-pd-l {
			rockchip,pins = <RK_GPIO0 4 RK_FUNC_GPIO
					 &pcfg_pull_down>;
		};
	};

	codec {
		/* Has external pullup */
		headset_int_l: headset-int-l {
			rockchip,pins = <1 23 RK_FUNC_GPIO &pcfg_pull_none>;
		};

		// TODO: check pull.  From signal name assume active high.
		mic_int: mic-int {
			rockchip,pins = <1 13 RK_FUNC_GPIO &pcfg_pull_down>;
		};
	};

	sdmmc {
		/*
		 * We run sdmmc at max speed; bump up drive strength.
		 * We also have external pulls, so disable the internal ones.
		 */
		sdmmc_bus4: sdmmc-bus4 {
			rockchip,pins =
				<4 8 RK_FUNC_1 &pcfg_pull_none_8ma>,
				<4 9 RK_FUNC_1 &pcfg_pull_none_8ma>,
				<4 10 RK_FUNC_1 &pcfg_pull_none_8ma>,
				<4 11 RK_FUNC_1 &pcfg_pull_none_8ma>;
		};

		sdmmc_clk: sdmmc-clk {
			rockchip,pins =
				<4 12 RK_FUNC_1 &pcfg_pull_none_8ma>;
		};

		sdmmc_cmd: sdmmc-cmd {
			rockchip,pins =
				<4 13 RK_FUNC_1 &pcfg_pull_none_8ma>;
		};

		/*
		 * In our case the official card detect is hooked to ground
		 * to avoid getting access to JTAG just by sticking something
		 * in the SD card slot (see the force_jtag bit in the TRM).
		 *
		 * We still configure it as card detect because it doesn't
		 * hurt and dw_mmc will ignore it.  We make sure to disable
		 * the pull though so we don't burn needless power.
		 */
		sdmmc_cd: sdmcc-cd {
			rockchip,pins =
				<0 7 RK_FUNC_1 &pcfg_pull_none>;
		};

		/* This is where we actually hook up CD; has external pull */
		sdmmc_cd_gpio: sdmmc-cd-gpio {
			rockchip,pins = <4 24 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};

	trackpad {
		ap_i2c_tp_pu_en: ap-i2c-tp-pu-en {
			rockchip,pins = <3 12 RK_FUNC_GPIO &pcfg_output_high>;
		};

		trackpad_int_l: trackpad-int-l {
			rockchip,pins = <1 4 RK_FUNC_GPIO &pcfg_pull_up>;
		};
	};

	touchscreen {
		touch_int_l: touch-int-l {
			rockchip,pins = <3 13 RK_FUNC_GPIO &pcfg_pull_up>;
		};
	};

	backlight-enable {
		bl_en: bl-en {
			rockchip,pins = <1 17 RK_FUNC_GPIO &pcfg_pull_none>;
		};
	};
};

/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */

